import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.HashSet;

/**
 * Implements construction, encoding, and decoding logic of the Huffman coding algorithm. Characters
 * not in the given seed or alphabet should not be compressible, and attempts to use those
 * characters should result in the throwing of an {@link IllegalArgumentException} if used in {@link
 * #compress(String)}.
 */
public class Huffman {
    
    class Node {
        //cs contains information about all characters below it
        Set<Character> cs = new HashSet<Character>(); 
        Node left, right; 
    }
    
    Node ht;
    
    //If Huffman is given a string: Seed -> Map -> Heap
    //If Huffman is given a map: Map -> Heap
    //The "Map -> Heap" process will be taken care of in this method:
    void makeTreeFromMap(Map<Character, Integer> alph) {
        BinaryMinHeap<Integer, Node> bin = new BinaryMinHeapImpl<Integer, Node>();
        for (Character c : alph.keySet()) {
            //Put everything in as a leaf
            Node n = new Node();
            n.cs.add(c);
            bin.add(alph.get(c), n);
        }
        //Grab two smallest entries, merge them, and insert back into heap
        while (bin.size() > 1) {
            BinaryMinHeap.Entry<Integer, Node> firstSmallest = bin.extractMin();
            BinaryMinHeap.Entry<Integer, Node> secondSmallest = bin.extractMin();
            Node merged = new Node();
            merged.cs.addAll(firstSmallest.value.cs);
            merged.cs.addAll(secondSmallest.value.cs);
            merged.left = firstSmallest.value;
            merged.right = secondSmallest.value;
            bin.add(firstSmallest.key + secondSmallest.key, merged);
        }
        if (bin.size() == 1) {
            ht = bin.extractMin().value;
        }
    }

    /**
     * Constructs a {@code Huffman} instance from a seed string, from which to deduce the alphabet
     * and corresponding frequencies.
     * <p/>
     * Do NOT modify this constructor header.
     *
     * @param seed the String from which to build the encoding
     * @throws IllegalArgumentException seed is null, seed is empty, or resulting alphabet only has
     *                                  1 character
     */
    public Huffman(String seed) {
        if ((seed == null) || (seed.length() < 2)) {
            throw new IllegalArgumentException();
        }
        Map<Character, Integer> map = new HashMap<Character, Integer>();
        //Iterate over every character in seed and do the following: check if counted in map, 
        //if so add by one, if not, give count in map
        for (int i = 0; i < seed.length() - 1; i++) {
            if (map.containsKey(seed.charAt(i))) {
                map.put(seed.charAt(i), map.get(seed.charAt(i))+ 1);
            } else {
                map.put(seed.charAt(i), 1);
            }
        }
        //Make a call to other constructor
        makeTreeFromMap(map);
    }
    
    /**
     * Constructs a {@code Huffman} instance from a frequency map of the input alphabet.
     * <p/>
     * Do NOT modify this constructor header.
     *
     * @param alphabet a frequency map for characters in the alphabet
     * @throws IllegalArgumentException if the alphabet is null, empty, has fewer than 2 characters,
     *                                  or has any non-positive frequencies
     */
    public Huffman(Map<Character, Integer> alphabet) {
        if ((alphabet == null) || (alphabet.size() < 2)) {
            throw new IllegalArgumentException();
        }
        for (Integer i : alphabet.values()) {
            if (i <= 0) {
                throw new IllegalArgumentException();
            }
        }
        makeTreeFromMap(alphabet);
    }

    /**
     * Compresses the input string.
     *
     * @param input the string to compress, can be the empty string
     * @return a string of ones and zeroes, representing the binary encoding of the inputted String.
     * @throws IllegalArgumentException if the input is null or if the input contains characters
     *                                  that are not compressible
     */
    public String compress(String input) {
        // TODO: implement
        throw new UnsupportedOperationException();
    }

    /**
     * Decompresses the input string.
     *
     * @param input the String of binary digits to decompress, given that it was generated by a
     *              matching instance of the same compression strategy
     * @return the decoded version of the compressed input string
     * @throws IllegalArgumentException if the input is null, or if the input contains characters
     *                                  that are NOT 0 or 1, or input contains a sequence of bits
     *                                  that is not decodable
     */
    public String decompress(String input) {
        // TODO: implement
        throw new UnsupportedOperationException();
    }

    /**
     * Computes the compression ratio so far. This is the length of all output strings from {@link
     * #compress(String)} divided by the length of all input strings to {@link #compress(String)}.
     * Assume that each char in the input string is a 16 bit int.
     *
     * @return the ratio of the total output length to the total input length in bits
     * @throws IllegalStateException if no calls have been made to {@link #compress(String)} before
     *                               calling this method
     */
    public double compressionRatio() {
        // TODO: implement
        throw new UnsupportedOperationException();
    }

    /**
     * Computes the expected encoding length of an arbitrary character in the alphabet based on the
     * objective function of the compression.
     * <p>
     * The expected encoding length is simply the sum of the length of the encoding of each
     * character multiplied by the probability that character occurs.
     *
     * @return the expected encoding length of an arbitrary character in the alphabet
     */
    public double expectedEncodingLength() {
        // TODO: implement
        throw new UnsupportedOperationException();
    }
}
